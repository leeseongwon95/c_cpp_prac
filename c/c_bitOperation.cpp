// 비트 연산
// 비트 논리 연산
// 시프트(shift) 연산

// 논리 연산 && || !
// 비트 연산 &  |  ^  ~

/*
  shift : 옮기다
  << >>
*/
#include <stdio.h>

int main() {
  char a = 12, b = 10;

  printf("%d\n", a & b);
  printf("%d\n", a | b);
  printf("%d\n", a ^ b);
  printf("%d\n", ~a);

  char a = 22;

  printf("%d\n", a << 1);
  printf("%d\n", a << 3);
  printf("%d\n", a << 6);
  printf("%d\n", a >> 1);
  printf("%d\n", a >> 3);
  printf("%d\n", a >> 6);
}

/*
  & 연산
  0000 1100 (2)        // a = 12
  0000 1010 (2)        // b = 10
  0000 1000 (2)        // 10진법 8

  | 연산
  0000 1100 (2)        // a = 12 
  0000 1010 (2)        // b = 10
  0000 1110 (2)        // 14 (10)

  ^ 연산 (xor) : 두개가 같을 때 0 두개가 다르면 1
  0000 1100 (2)        // a
  0000 1010 (2)        // b
  0000 0110 (2)        // 6 (10)

  ~ 연산 (반전시킴 : 토글) 보수 
  0000 1100 (2)

  1111 0011 (2)

  12의 ~이 -13인 이유

  1의 보수와 2의 보수 개념을 알고 계셔야 합니다.
  컴퓨터는 뺄셈이 불가능하여 덧셈을 이용한 뺄셈 연산을 하는데, 이때 필요한것이 보수입니다.

  보수 중에서도 2의 보수를 사용하게 됩니다.
  1의 보수를 나타내는 연산이 ~연산인데
  0000 1100 (12) 를 1의 보수로 나타내면
  1111 0011이 됩니다.

  이때 최상위 비트 1은 부호를 나타냅니다.
  0이면 +
  1이면 -

  아까 말씀드린대로 컴퓨터는 뺄셈을 위해 
  2의 보수를 사용한다 말씀드렸는데
  2의 보수는 1의 보수에 +1한것이 2의 보수가됩니다.

  0000 1100 -> 12
  1111 0011 -> 12의 1의보수
  1111 0100 -> 12의 2의보수

    0000 1100
  + 1111 0100
  1 0000 0000
  맨 앞 1은 9번째 비트이므로 제거
  따라서 0000 0000이 나오게되고
  즉 12 + 12의 2의보수 = 0이 나오게 됩니다.

  이제 연산을 다시 돌아가보면 
  2의 보수는 1의 보수에서 +1
  1의 보수는 ~연산
  1의 보수를 구하기위해서는 2의 보수 -1 을 하는것과 마찬가지 인 결론에 도달하게 됩니다.

  12 의 2의보수 = -12
  12 의 1의보수 = -12-1
  따라서 -13 이 나오게됩니다.
*/

/*
  char : -128 ~ 127


*/